# 069 Polish Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Deliver one polish PR that improves rclone branding and sidebar/settings UX, migrates suitable dialogs to the shared wizard system, refactors storage-service into trait-driven orchestration handlers, and adds workspace-wide FS-tool feature gates (default enabled).

**Architecture:** UI polish is implemented first in small, testable slices (icon resolution, sidebar images section behavior, wizard migration policy, settings layout). Service refactor then introduces per-domain trait boundaries so DBus handlers coordinate only auth/validation/delegation/error mapping. Feature flags are added last with capability-based behavior so compile-time exclusions do not break runtime UX.

**Tech Stack:** Rust workspace, COSMIC/iced UI, zbus DBus service, cargo features, tracing, unit tests.

---

### Task 1: Branded rclone icon resolution (with compliant fallback)

**Files:**
- Create: `storage-ui/src/ui/network/icons.rs`
- Modify: `storage-ui/src/ui/network/mod.rs`
- Modify: `storage-ui/src/ui/network/state.rs`
- Modify: `storage-ui/src/ui/network/view.rs`
- Test: `storage-ui/src/ui/network/icons.rs` (inline `#[cfg(test)]` module)

**Step 1: Write the failing test**

```rust
#[test]
fn resolves_known_provider_to_brand_icon_then_falls_back() {
    let known = resolve_provider_icon("dropbox");
    assert!(known.primary.is_some());
    assert!(!known.fallback_symbolic.is_empty());

    let unknown = resolve_provider_icon("unknown-provider");
    assert!(unknown.primary.is_none());
    assert_eq!(unknown.fallback_symbolic, "folder-remote-symbolic");
}
```

**Step 2: Run test to verify it fails**

Run: `cargo test -p storage-ui resolve_provider_icon -- --nocapture`
Expected: FAIL with unresolved function/module.

**Step 3: Write minimal implementation**

```rust
pub struct ProviderIcon {
    pub primary: Option<&'static str>,
    pub fallback_symbolic: &'static str,
}

pub fn resolve_provider_icon(provider: &str) -> ProviderIcon {
    match provider.to_ascii_lowercase().as_str() {
        "dropbox" => ProviderIcon { primary: Some("brand-dropbox-symbolic"), fallback_symbolic: "folder-remote-symbolic" },
        "drive" | "google drive" => ProviderIcon { primary: Some("brand-google-drive-symbolic"), fallback_symbolic: "folder-remote-symbolic" },
        "onedrive" => ProviderIcon { primary: Some("brand-onedrive-symbolic"), fallback_symbolic: "folder-remote-symbolic" },
        "s3" => ProviderIcon { primary: Some("brand-amazon-s3-symbolic"), fallback_symbolic: "network-server-symbolic" },
        _ => ProviderIcon { primary: None, fallback_symbolic: "folder-remote-symbolic" },
    }
}
```

**Step 4: Run test to verify it passes**

Run: `cargo test -p storage-ui resolve_provider_icon -- --nocapture`
Expected: PASS.

**Step 5: Commit**

```bash
git add storage-ui/src/ui/network/icons.rs storage-ui/src/ui/network/mod.rs storage-ui/src/ui/network/state.rs storage-ui/src/ui/network/view.rs
git commit -m "feat(ui): add branded rclone provider icon resolution"
```

### Task 2: Sidebar Images section visibility and right-aligned actions

**Files:**
- Modify: `storage-ui/src/ui/sidebar/view.rs`
- Test: `storage-ui/src/ui/sidebar/view.rs` (small helper tests if helper extraction is added)

**Step 1: Write the failing test**

```rust
#[test]
fn images_section_header_renders_even_with_no_image_drives() {
    let sections = build_section_model(&[], true);
    assert!(sections.iter().any(|s| s.label == "Images"));
}
```

**Step 2: Run test to verify it fails**

Run: `cargo test -p storage-ui images_section_header_renders_even_with_no_image_drives -- --nocapture`
Expected: FAIL with missing helper/behavior.

**Step 3: Write minimal implementation**

```rust
// Ensure Images section is pushed even if images vec is empty
rows.push(section_header(Section::Images.label()));
for drive in images {
    // existing rendering path
}

let image_actions = widget::Row::new()
    .push(widget::Space::new(Length::Fill, 0))
    .push(new_image_button)
    .push(attach_image_button);
```

**Step 4: Run test to verify it passes**

Run: `cargo test -p storage-ui images_section_header_renders_even_with_no_image_drives -- --nocapture`
Expected: PASS.

**Step 5: Commit**

```bash
git add storage-ui/src/ui/sidebar/view.rs
git commit -m "feat(sidebar): keep Images section visible and right-align image actions"
```

### Task 3: Wizard migration for non-trivial dialogs only

**Files:**
- Modify: `storage-ui/src/ui/dialogs/state.rs`
- Modify: `storage-ui/src/ui/app/view.rs`
- Modify: `storage-ui/src/ui/app/update/mod.rs`
- Modify: `storage-ui/src/ui/app/update/image/dialogs.rs`
- Modify: `storage-ui/src/ui/wizard.rs`
- Test: `storage-ui/src/ui/app/update/image/dialogs.rs` (state transition tests)

**Step 1: Write the failing test**

```rust
#[test]
fn image_operation_flow_uses_wizard_state_and_keeps_confirm_dialogs_unmigrated() {
    let mut app = AppModel::default_for_test();
    start_image_operation_wizard(&mut app);
    assert!(app.image_wizard.is_some());
    assert!(matches!(app.dialog, None));
}
```

**Step 2: Run test to verify it fails**

Run: `cargo test -p storage-ui image_operation_flow_uses_wizard_state_and_keeps_confirm_dialogs_unmigrated -- --nocapture`
Expected: FAIL because wizard state path does not exist yet.

**Step 3: Write minimal implementation**

```rust
// Introduce wizard-backed states for multi-step image flows
pub enum ImageFlowState {
    NewDiskImage(NewDiskImageWizard),
    AttachDiskImage(AttachDiskWizard),
    ImageOperation(ImageOperationWizard),
}

// Keep simple confirm/single-value dialogs as-is
```

**Step 4: Run test to verify it passes**

Run: `cargo test -p storage-ui image_operation_flow_uses_wizard_state_and_keeps_confirm_dialogs_unmigrated -- --nocapture`
Expected: PASS.

**Step 5: Commit**

```bash
git add storage-ui/src/ui/dialogs/state.rs storage-ui/src/ui/app/view.rs storage-ui/src/ui/app/update/mod.rs storage-ui/src/ui/app/update/image/dialogs.rs storage-ui/src/ui/wizard.rs
git commit -m "refactor(ui): migrate non-trivial image dialogs to shared wizard shell"
```

### Task 4: Settings pane cleanup and repository affordance placement

**Files:**
- Modify: `storage-ui/src/views/settings.rs`
- Modify: `storage-ui/src/ui/app/view.rs` (only if needed for context sizing/placement)
- Test: `storage-ui/src/views/settings.rs` (view-level helper tests if extracted)

**Step 1: Write the failing test**

```rust
#[test]
fn settings_footer_places_commit_caption_left_of_repo_icon() {
    let model = settings_footer_model("abc1234", "2026-02-24");
    assert_eq!(model.trailing.len(), 2);
    assert_eq!(model.trailing[0].kind, FooterItemKind::CommitCaption);
    assert_eq!(model.trailing[1].kind, FooterItemKind::RepoIconButton);
}
```

**Step 2: Run test to verify it fails**

Run: `cargo test -p storage-ui settings_footer_places_commit_caption_left_of_repo_icon -- --nocapture`
Expected: FAIL due to missing footer model/placement logic.

**Step 3: Write minimal implementation**

```rust
let footer = widget::row()
    .push(widget::Space::new(Length::Fill, 0))
    .push(widget::text::caption(commit_caption))
    .push(widget::button::icon(icon::from_name("web-github-symbolic")).on_press(Message::OpenRepositoryUrl));
```

**Step 4: Run test to verify it passes**

Run: `cargo test -p storage-ui settings_footer_places_commit_caption_left_of_repo_icon -- --nocapture`
Expected: PASS.

**Step 5: Commit**

```bash
git add storage-ui/src/views/settings.rs storage-ui/src/ui/app/view.rs
git commit -m "feat(settings): simplify about panel and move repo controls to bottom-right"
```

### Task 5: Trait-driven service orchestration across all handlers

**Files:**
- Create: `storage-service/src/service/domain/mod.rs`
- Create: `storage-service/src/service/domain/filesystems.rs`
- Create: `storage-service/src/service/domain/disks.rs`
- Create: `storage-service/src/service/domain/partitions.rs`
- Create: `storage-service/src/service/domain/luks.rs`
- Create: `storage-service/src/service/domain/lvm.rs`
- Create: `storage-service/src/service/domain/image.rs`
- Create: `storage-service/src/service/domain/rclone.rs`
- Create: `storage-service/src/service/domain/btrfs.rs`
- Modify: `storage-service/src/filesystems.rs`
- Modify: `storage-service/src/disks.rs`
- Modify: `storage-service/src/partitions.rs`
- Modify: `storage-service/src/luks.rs`
- Modify: `storage-service/src/lvm.rs`
- Modify: `storage-service/src/image.rs`
- Modify: `storage-service/src/rclone.rs`
- Modify: `storage-service/src/btrfs.rs`
- Modify: `storage-service/src/main.rs`
- Test: handler modules with targeted unit tests around delegation and error mapping

**Step 1: Write the failing test**

```rust
#[tokio::test]
async fn filesystems_handler_delegates_to_trait_service() {
    let fake = FakeFilesystemsDomain::default();
    let handler = FilesystemsHandler::with_domain(Box::new(fake.clone()));
    let _ = handler.supported_filesystems().await;
    assert_eq!(fake.calls("supported_filesystems"), 1);
}
```

**Step 2: Run test to verify it fails**

Run: `cargo test -p storage-service filesystems_handler_delegates_to_trait_service -- --nocapture`
Expected: FAIL because trait injection path is missing.

**Step 3: Write minimal implementation**

```rust
pub trait FilesystemsDomain: Send + Sync {
    fn supported_filesystems(&self) -> Vec<String>;
}

pub struct FilesystemsHandler {
    domain: Arc<dyn FilesystemsDomain>,
}

impl FilesystemsHandler {
    pub fn with_domain(domain: Arc<dyn FilesystemsDomain>) -> Self { Self { domain } }
}
```

**Step 4: Run test to verify it passes**

Run: `cargo test -p storage-service filesystems_handler_delegates_to_trait_service -- --nocapture`
Expected: PASS.

**Step 5: Commit**

```bash
git add storage-service/src/main.rs storage-service/src/filesystems.rs storage-service/src/disks.rs storage-service/src/partitions.rs storage-service/src/luks.rs storage-service/src/lvm.rs storage-service/src/image.rs storage-service/src/rclone.rs storage-service/src/btrfs.rs storage-service/src/service/domain
git commit -m "refactor(service): convert handlers to trait-driven orchestration"
```

### Task 6: Workspace feature flags for filesystem-tool dependent behavior

**Files:**
- Modify: `storage-service/Cargo.toml`
- Modify: `storage-sys/Cargo.toml`
- Modify: `storage-ui/Cargo.toml`
- Modify: `storage-service/src/filesystems.rs`
- Modify: `storage-sys/src/**/*` (FS-tool call sites)
- Modify: `storage-ui/src/**/*` (capability gating at UI affordance layer)
- Test: compile matrix commands in CI/local docs

**Step 1: Write the failing compile-check commands**

```bash
cargo check -p storage-service --no-default-features
cargo check -p storage-service --no-default-features --features fs-ext4
cargo check -p storage-service --no-default-features --features fs-btrfs,fs-xfs
```

**Step 2: Run checks to verify failure baseline**

Run: the three commands above.
Expected: FAIL due to ungated references to disabled FS-tool code.

**Step 3: Write minimal implementation**

```toml
[features]
default = ["fs-ext4", "fs-xfs", "fs-btrfs", "fs-vfat", "fs-ntfs", "fs-exfat"]
fs-ext4 = []
fs-xfs = []
fs-btrfs = []
fs-vfat = []
fs-ntfs = []
fs-exfat = []
```

```rust
#[cfg(feature = "fs-btrfs")]
fn btrfs_tool_available() -> bool { which::which("mkfs.btrfs").is_ok() }

#[cfg(not(feature = "fs-btrfs"))]
fn btrfs_tool_available() -> bool { false }
```

**Step 4: Run checks to verify pass**

Run:
- `cargo check -p storage-service --no-default-features`
- `cargo check -p storage-service --no-default-features --features fs-ext4`
- `cargo check -p storage-service --no-default-features --features fs-btrfs,fs-xfs`
- `cargo fmt --all -- --check`
- `cargo clippy --workspace --all-targets -- -D warnings`
- `cargo test --workspace`

Expected: all targeted checks pass (or only unrelated pre-existing failures remain).

**Step 5: Commit**

```bash
git add storage-service/Cargo.toml storage-sys/Cargo.toml storage-ui/Cargo.toml storage-service/src/filesystems.rs storage-sys/src storage-ui/src
git commit -m "feat(workspace): add filesystem-tool feature gating with default-on capabilities"
```

### Task 7: CI and docs updates for feature matrix and polish coverage

**Files:**
- Modify: `.github/workflows/ci.yml`
- Modify: `README.md`
- Modify: `docs/plans/2026-02-24-069-polish-design.md` (status notes only, if needed)

**Step 1: Write failing CI expectation (locally simulate)**

Run: `cargo check -p storage-service --no-default-features` in CI-equivalent environment.
Expected: currently not enforced in workflow.

**Step 2: Add minimal CI matrix**

```yaml
- name: Check service feature-minimum
  run: cargo check -p storage-service --no-default-features
- name: Check service selective features
  run: cargo check -p storage-service --no-default-features --features fs-ext4,fs-btrfs
```

**Step 3: Update docs minimally**

```md
- FS tool support is compile-gated via cargo features (default enabled).
- UI shows capability-driven availability when features are disabled.
```

**Step 4: Run workflow-equivalent checks locally**

Run: `just check` (or equivalent workspace checks already used by repo).
Expected: PASS or only unrelated known failures.

**Step 5: Commit**

```bash
git add .github/workflows/ci.yml README.md docs/plans/2026-02-24-069-polish-design.md
git commit -m "ci/docs: validate feature-gated builds and document capability behavior"
```

### Task 8: Final verification and PR prep

**Files:**
- Modify: none expected (only if verification exposes regressions)

**Step 1: Run focused regression checks**

Run:
- `cargo test -p storage-ui`
- `cargo test -p storage-service`
- `cargo test -p storage-sys`

Expected: PASS.

**Step 2: Run full workspace quality gates**

Run:
- `cargo fmt --all -- --check`
- `cargo clippy --workspace --all-targets -- -D warnings`
- `cargo test --workspace`

Expected: PASS.

**Step 3: Smoke-check key flows manually**

- Network provider icon appearance in sidebar and wizard.
- Images section visibility with and without image drives.
- Settings footer layout (commit caption + GitHub icon placement).
- Wizardized image flows and unchanged simple confirm dialogs.
- Feature-disabled build path and capability UI behavior.

**Step 4: Prepare PR summary**

Include:
- UX polish changes
- Service architecture refactor boundaries
- Feature-flag matrix behavior
- Validation evidence

**Step 5: Commit any final fixups**

```bash
git add -A
git commit -m "chore: final polish verification adjustments"
```
