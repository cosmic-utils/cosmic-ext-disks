# GAP-001.b: Complete storage-dbus Restructuring - Flat Domain-Based Architecture

**Parent:** GAP-001 (Storage Service Abstraction Layers)  
**Type:** Major Refactoring (Complete Codebase Reorganization)  
**Effort:** 5-7 days  
**Status:** Planned  
**Priority:** Medium (stretch goal - improves maintainability and consistency)

---

## Problem Statement

Currently, `storage-dbus` has **multiple inconsistent architectural patterns** scattered across the codebase:

### Current State (Inconsistent)

1. **operations/** (created in GAP-001) - ‚úÖ Clean flat functions
   - `operations/partitions.rs` - 7 operations (create_table, create, delete, resize, etc.)
   - `operations/filesystems.rs` - 8 operations (format, mount, unmount, check, etc.)
   - `operations/luks.rs` - 5 operations (unlock, lock, change_passphrase, etc.)
   - Pattern: `pub async fn operation(device: &str, ...) -> Result<T>`

2. **disks/drive/** - ‚ö†Ô∏è OOP methods on DriveModel (6 files, 1,453 lines)
   - `drive/actions.rs` - Methods: eject, power_off, create_partition, format_disk, etc.
   - `drive/smart.rs` - Methods: smart_info, smart_selftest_start/abort
   - Pattern: `drive_model.operation(...) -> Result<T>`

3. **disks/volume_model/** - ‚ö†Ô∏è OOP methods on VolumeModel (7 files, 994 lines)
   - `volume_model/partition.rs` - Methods: edit_partition, resize, delete
   - `volume_model/filesystem.rs` - Methods: format, check, repair, edit_label
   - `volume_model/mount.rs` - Methods: mount, unmount, mount options
   - `volume_model/encryption.rs` - Methods: unlock, lock, change_passphrase
   - Pattern: `volume_model.operation(...) -> Result<T>`

4. **disks/** - ‚ö†Ô∏è Mixed patterns (standalone modules)
   - `image.rs` - Flat functions: loop_setup, mount_filesystem, open_for_backup/restore
   - `lvm.rs` - Flat function: list_lvs_for_pv
   - `smart.rs` - Type definitions only
   - `gpt.rs` - Helper functions
   - `btrfs_native.rs` - Type definitions
   - `manager.rs` - DiskManager struct with event stream
   - `ops.rs` - Backend trait abstraction
   - `process_finder.rs` - Utility functions
   - `volume.rs` - VolumeNode type definition

**Critical Problems:**

1. **Duplicated Operations:**
   - Partition operations exist in BOTH `/operations/partitions.rs` AND `/volume_model/partition.rs`
   - Filesystem operations exist in BOTH `/operations/filesystems.rs` AND `/volume_model/filesystem.rs`
   - Encryption operations exist in BOTH `/operations/luks.rs` AND `/volume_model/encryption.rs`
   - Different implementations with varying quality (some better in operations, some better in volume_model)

2. **Architectural Inconsistency:**
   - Three different patterns: flat functions, OOP methods, mixed
   - No clear organization principle
   - Hard to discover available operations

3. **Navigation Difficulty:**
   - Related operations scattered across multiple locations
   - No clear place to look for "all partition operations" or "all filesystem operations"

4. **Maintenance Burden:**
   - Changes must be synchronized across duplicates
   - Testing requires different approaches for each pattern
   - Adding new operations requires choosing a pattern

---

## Proposed Solution

**Complete restructuring** of storage-dbus into consistent domain-based flat function modules. Remove ALL duplicates by merging and keeping the best implementations.

### New Architecture (Consistent & Complete)

```
storage-dbus/src/
‚îú‚îÄ‚îÄ lib.rs                    (exports everything at top level)
‚îÇ
‚îú‚îÄ‚îÄ error.rs                  (shared error types)
‚îú‚îÄ‚îÄ types.rs                  (shared type definitions)
‚îÇ
‚îú‚îÄ‚îÄ disk/                     üÜï Disk-level operations
‚îÇ   ‚îú‚îÄ‚îÄ mod.rs
‚îÇ   ‚îú‚îÄ‚îÄ discovery.rs          (get_drives, get_disks, enumerate)
‚îÇ   ‚îú‚îÄ‚îÄ format.rs             (format_disk, create_partition_table)
‚îÇ   ‚îú‚îÄ‚îÄ power.rs              (eject, power_off, standby, wakeup)
‚îÇ   ‚îú‚îÄ‚îÄ model.rs              (DriveModel struct - data only)
‚îÇ   ‚îî‚îÄ‚îÄ volume_tree.rs        (internal: volume hierarchy building)
‚îÇ
‚îú‚îÄ‚îÄ partition/                üÜï Partition operations
‚îÇ   ‚îú‚îÄ‚îÄ mod.rs
‚îÇ   ‚îú‚îÄ‚îÄ create.rs             (create_partition)
‚îÇ   ‚îú‚îÄ‚îÄ delete.rs             (delete_partition)
‚îÇ   ‚îú‚îÄ‚îÄ edit.rs               (set_type, set_name, set_flags, edit_all)
‚îÇ   ‚îú‚îÄ‚îÄ resize.rs             (resize_partition)
‚îÇ   ‚îî‚îÄ‚îÄ info.rs               (partition_info, flags helpers)
‚îÇ
‚îú‚îÄ‚îÄ filesystem/               üÜï Filesystem operations
‚îÇ   ‚îú‚îÄ‚îÄ mod.rs
‚îÇ   ‚îú‚îÄ‚îÄ format.rs             (format_filesystem)
‚îÇ   ‚îú‚îÄ‚îÄ mount.rs              (mount, unmount)
‚îÇ   ‚îú‚îÄ‚îÄ check.rs              (check_filesystem, repair_filesystem)
‚îÇ   ‚îú‚îÄ‚îÄ label.rs              (get_label, set_label)
‚îÇ   ‚îú‚îÄ‚îÄ ownership.rs          (take_ownership)
‚îÇ   ‚îî‚îÄ‚îÄ config.rs             (mount options management)
‚îÇ
‚îú‚îÄ‚îÄ encryption/               üÜï LUKS/encryption operations
‚îÇ   ‚îú‚îÄ‚îÄ mod.rs
‚îÇ   ‚îú‚îÄ‚îÄ format.rs             (format_luks)
‚îÇ   ‚îú‚îÄ‚îÄ unlock.rs             (unlock_luks)
‚îÇ   ‚îú‚îÄ‚îÄ lock.rs               (lock_luks)
‚îÇ   ‚îú‚îÄ‚îÄ passphrase.rs         (change_passphrase)
‚îÇ   ‚îú‚îÄ‚îÄ list.rs               (list_luks_devices)
‚îÇ   ‚îî‚îÄ‚îÄ config.rs             (encryption options - crypttab management)
‚îÇ
‚îú‚îÄ‚îÄ image/                    üÜï Image/backup operations
‚îÇ   ‚îú‚îÄ‚îÄ mod.rs
‚îÇ   ‚îú‚îÄ‚îÄ loop.rs               (loop_setup, loop_delete)
‚îÇ   ‚îú‚îÄ‚îÄ mount.rs              (mount_filesystem for images)
‚îÇ   ‚îî‚îÄ‚îÄ backup.rs             (open_for_backup, open_for_restore)
‚îÇ
‚îú‚îÄ‚îÄ smart/                    üÜï SMART monitoring
‚îÇ   ‚îú‚îÄ‚îÄ mod.rs
‚îÇ   ‚îú‚îÄ‚îÄ info.rs               (get_smart_info)
‚îÇ   ‚îú‚îÄ‚îÄ test.rs               (start_selftest, abort_selftest)
‚îÇ   ‚îî‚îÄ‚îÄ types.rs              (SmartInfo, SmartSelfTestKind definitions)
‚îÇ
‚îú‚îÄ‚îÄ lvm/                      üÜï LVM operations
‚îÇ   ‚îú‚îÄ‚îÄ mod.rs
‚îÇ   ‚îú‚îÄ‚îÄ list.rs               (list_lvs_for_pv)
‚îÇ   ‚îî‚îÄ‚îÄ (future: create_lv, delete_lv, etc.)
‚îÇ
‚îú‚îÄ‚îÄ btrfs/                    üÜï BTRFS-specific operations
‚îÇ   ‚îú‚îÄ‚îÄ mod.rs
‚îÇ   ‚îî‚îÄ‚îÄ types.rs              (BtrfsFilesystem, BtrfsSubvolume)
‚îÇ
‚îú‚îÄ‚îÄ gpt/                      üÜï GPT utilities
‚îÇ   ‚îú‚îÄ‚îÄ mod.rs
‚îÇ   ‚îî‚îÄ‚îÄ probe.rs              (probe_gpt_usable_range_bytes, fallback)
‚îÇ
‚îú‚îÄ‚îÄ manager/                  üÜï Device event monitoring
‚îÇ   ‚îú‚îÄ‚îÄ mod.rs
‚îÇ   ‚îú‚îÄ‚îÄ events.rs             (DeviceEvent, DeviceEventStream)
‚îÇ   ‚îî‚îÄ‚îÄ disk_manager.rs       (DiskManager)
‚îÇ
‚îú‚îÄ‚îÄ volume/                   üÜï Volume hierarchy
‚îÇ   ‚îú‚îÄ‚îÄ mod.rs
‚îÇ   ‚îú‚îÄ‚îÄ node.rs               (VolumeNode type)
‚îÇ   ‚îú‚îÄ‚îÄ index.rs              (BlockIndex)
‚îÇ   ‚îî‚îÄ‚îÄ model.rs              (VolumeModel struct - data only)
‚îÇ
‚îî‚îÄ‚îÄ util/                     üÜï Shared utilities
    ‚îú‚îÄ‚îÄ mod.rs
    ‚îú‚îÄ‚îÄ bytestring.rs         (D-Bus bytestring helpers)
    ‚îú‚îÄ‚îÄ path.rs               (path conversion helpers)
    ‚îî‚îÄ‚îÄ process.rs            (find_processes_using_mount, kill_processes)
```

**Note:** The old `DiskBackend` trait abstraction (ops.rs with RealDiskBackend/FakeBackend) will be **completely removed** in Phase 9. Direct calls to domain functions replace the trait pattern.

### Key Design Principles

1. **Domain-Based Organization**
   - Each domain gets its own folder: `disk/`, `partition/`, `filesystem/`, `encryption/`, etc.
   - Operations grouped by what they operate on, not by implementation details

2. **Flat Functions Everywhere**
   - All operations are flat functions: `pub async fn operation(identifier, ...) -> Result<T>`
   - No methods on model structs (models are data-only)
   - Consistent API across entire codebase

3. **Data-Only Models**
   - `DriveModel` in `disk/model.rs` - struct with public fields, constructors only
   - `VolumeModel` in `volume/model.rs` - struct with public fields, constructors only
   - Models used for discovery and data passing, not for operation invocation

4. **No Duplicates**
   - Merge operations from /operations, drive/, and volume_model/
   - Keep the best implementation of each operation
   - Delete all redundant code

5. **Clear Module Boundaries**
   - Each module has single responsibility
   - Helper functions in util/
   - Type definitions in types.rs or domain-specific types.rs

6. **Top-Level Exports**
   - All operations re-exported from lib.rs
   - Single import point: `use disks_dbus::*;` gives access to everything
   - Or selective: `use disks_dbus::partition::*;`

---

## Detailed Task Breakdown

### Phase 1: Create New Module Structure (Day 1 morning - 2-3 hours)

**Goal:** Set up the new folder structure and move type definitions

**Steps:**

1. Create all new directories:
```bash
mkdir -p storage-dbus/src/{disk,partition,filesystem,encryption,image,smart,lvm,btrfs,gpt,manager,volume,util}
```

2. Create initial `mod.rs` files for each domain

3. Move type definitions:
   - `disks/smart.rs` types ‚Üí `smart/types.rs`
   - `disks/btrfs_native.rs` types ‚Üí `btrfs/types.rs`
   - `disks/volume.rs` types ‚Üí `volume/node.rs` + `volume/index.rs`
   - Create `types.rs` at root for shared types

4. Move model structs (data-only):
   - `disks/drive/model.rs` ‚Üí `disk/model.rs` (strip all methods)
   - `disks/volume_model/mod.rs` VolumeModel ‚Üí `volume/model.rs` (strip all methods)

5. Update `lib.rs` to export new structure (initially empty re-exports)

**Test:** Workspace should still compile with type definitions accessible

---

### Phase 2: Merge Duplicate Operations & Flatten Partitions (Day 1 afternoon - 3-4 hours)

**Goal:** Create unified `partition/` module by merging operations

**Duplicates to resolve:**

| Operation | Source 1 (operations) | Source 2 (volume_model) | Decision |
|-----------|----------------------|------------------------|----------|
| create_partition_table | operations/partitions.rs | drive/actions.rs (format_disk) | Keep operations - more direct |
| create_partition | operations/partitions.rs | drive/actions.rs | Keep operations - complete |
| delete_partition | operations/partitions.rs | volume_model/partition.rs | **Merge** - volume_model has unmount-first logic |
| resize_partition | operations/partitions.rs | volume_model/partition.rs | Keep operations - simpler |
| set_partition_type | operations/partitions.rs | volume_model/partition.rs | Keep operations |
| set_partition_name | operations/partitions.rs | volume_model/partition.rs | Keep operations |
| set_partition_flags | operations/partitions.rs | volume_model/partition.rs | Keep operations |
| edit_partition (all-in-one) | ‚ùå | volume_model/partition.rs | **Keep** - useful convenience wrapper |

**New `partition/` module:**

`partition/create.rs`:
```rust
/// Create a partition table on a disk
pub async fn create_partition_table(disk_path: &str, table_type: &str) -> Result<()> {
    // From operations/partitions.rs - already good
}

/// Create a partition
pub async fn create_partition(
    disk_path: &str,
    offset: u64,
    size: u64,
    type_id: &str,
) -> Result<String> {
    // From operations/partitions.rs - already good
}
```

`partition/delete.rs`:
```rust
/// Delete a partition (with automatic unmount)
pub async fn delete_partition(partition_path: &str) -> Result<()> {
    // MERGE: operations version + volume_model unmount logic
    // 1. Try to unmount first (from volume_model)
    let _ = crate::filesystem::unmount_filesystem(partition_path, false).await;
    
    // 2. Delete partition (from operations)
    let connection = Connection::system().await?;
    let partition_proxy = PartitionProxy::builder(&connection)
        .path(partition_path)?
        .build()
        .await?;
    partition_proxy.delete(HashMap::new()).await?;
    Ok(())
}
```

`partition/resize.rs`:
```rust
/// Resize a partition
pub async fn resize_partition(partition_path: &str, new_size_bytes: u64) -> Result<()> {
    // From operations/partitions.rs - already good
}
```

`partition/edit.rs`:
```rust
/// Set partition type
pub async fn set_partition_type(partition_path: &str, type_id: &str) -> Result<()> {
    // From operations/partitions.rs
}

/// Set partition name
pub async fn set_partition_name(partition_path: &str, name: &str) -> Result<()> {
    // From operations/partitions.rs
}

/// Set partition flags
pub async fn set_partition_flags(partition_path: &str, flags: u64) -> Result<()> {
    // From operations/partitions.rs
}

/// Edit partition (all-in-one: type, name, and flags)
pub async fn edit_partition(
    partition_path: &str,
    partition_type: &str,
    name: &str,
    flags: u64,
) -> Result<()> {
    // From volume_model/partition.rs - convenient wrapper
    set_partition_type(partition_path, partition_type).await?;
    set_partition_name(partition_path, name).await?;
    set_partition_flags(partition_path, flags).await?;
    Ok(())
}
```

`partition/info.rs`:
```rust
/// Helper functions from volume_model
pub fn make_partition_flags_bits(
    legacy_bios_bootable: bool,
    system_partition: bool,
    hidden: bool,
) -> u64 {
    // From volume_model/partition.rs
}
```

**Delete after merge:**
- `operations/partitions.rs` (logic moved to partition/)
- `disks/volume_model/partition.rs` (logic moved to partition/)

---

### Phase 3: Flatten Filesystem Operations (Day 2 morning - 3-4 hours)

**Goal:** Create unified `filesystem/` module

**Duplicates to resolve:**

| Operation | Source 1 (operations) | Source 2 (volume_model) | Decision |
|-----------|----------------------|------------------------|----------|
| format_filesystem | operations/filesystems.rs | volume_model/filesystem.rs | **Merge** - both have value |
| mount | operations/filesystems.rs (mount_filesystem) | volume_model/mount.rs | Keep operations |
| unmount | operations/filesystems.rs | volume_model/mount.rs | Keep operations |
| check_filesystem | operations/filesystems.rs | volume_model/filesystem.rs | **Compare** implementations |
| repair_filesystem | ‚ùå | volume_model/filesystem.rs | Keep volume_model |
| set_label | operations/filesystems.rs | volume_model/filesystem.rs | Keep operations |
| get_label | operations/filesystems.rs | ‚ùå | Keep operations |
| take_ownership | operations/filesystems.rs | volume_model/filesystem.rs | Keep operations |
| get_mount_point | operations/filesystems.rs | ‚ùå | Keep operations |

**New `filesystem/` module:**

`filesystem/format.rs`:
```rust
pub async fn format_filesystem(
    device: &str,
    fs_type: &str,
    label: &str,
    options: HashMap<String, Value>,
) -> Result<()> {
    // From operations/filesystems.rs - more complete
}
```

`filesystem/mount.rs`:
```rust
pub async fn mount_filesystem(device: &str) -> Result<String> {
    // From operations/filesystems.rs
}

pub async fn unmount_filesystem(device_or_mount: &str, force: bool) -> Result<()> {
    // From operations/filesystems.rs
}

pub async fn get_mount_point(device: &str) -> Result<String> {
    // From operations/filesystems.rs
}
```

`filesystem/check.rs`:
```rust
pub async fn check_filesystem(device_path: &str, repair: bool) -> Result<bool> {
    // From operations/filesystems.rs - has repair option
}

pub async fn repair_filesystem(device_path: &str) -> Result<()> {
    // Convenience wrapper
    check_filesystem(device_path, true)?;
    Ok(())
}
```

`filesystem/label.rs`:
```rust
pub async fn get_filesystem_label(device: &str) -> Result<String> {
    // From operations/filesystems.rs
}

pub async fn set_filesystem_label(device_path: &str, label: &str) -> Result<()> {
    // From operations/filesystems.rs
}
```

`filesystem/ownership.rs`:
```rust
pub async fn take_filesystem_ownership(device: &str, recursive: bool) -> Result<()> {
    // From operations/filesystems.rs
}
```

`filesystem/config.rs`:
```rust
// Mount options management from volume_model/mount.rs
pub async fn get_mount_options(volume_path: &str) -> Result<Option<MountOptionsSettings>> {
    // From volume_model/mount.rs
}

pub async fn set_mount_options(volume_path: &str, settings: MountOptionsSettings) -> Result<()> {
    // From volume_model/mount.rs
}

pub async fn reset_mount_options(volume_path: &str) -> Result<()> {
    // From volume_model/mount.rs (was default_mount_options)
}
```

**Delete after merge:**
- `operations/filesystems.rs` (logic moved to filesystem/)
- `disks/volume_model/filesystem.rs` (logic moved to filesystem/)
- `disks/volume_model/mount.rs` (logic moved to filesystem/)
- `disks/volume_model/config.rs` (tiny file, helpers moved)

---

### Phase 4: Flatten Encryption Operations (Day 2 afternoon - 2-3 hours)

**Goal:** Create unified `encryption/` module

**Duplicates to resolve:**

| Operation | Source 1 (operations) | Source 2 (volume_model) | Decision |
|-----------|----------------------|------------------------|----------|
| format_luks | operations/luks.rs | ‚ùå | Keep operations |
| unlock_luks | operations/luks.rs | volume_model/encryption.rs | Keep operations - more complete |
| lock_luks | operations/luks.rs | volume_model/encryption.rs | Keep operations |
| change_passphrase | operations/luks.rs | volume_model/encryption.rs | Keep operations |
| list_luks_devices | operations/luks.rs | ‚ùå | Keep operations |
| get_encryption_options | ‚ùå | volume_model/encryption.rs | Keep volume_model |
| set_encryption_options | ‚ùå | volume_model/encryption.rs | Keep volume_model |

**New `encryption/` module:**

`encryption/format.rs`:
```rust
pub async fn format_luks(
    device: &str,
    passphrase: &str,
    version: &str, // "luks1" or "luks2"
) -> Result<()> {
    // From operations/luks.rs
}
```

`encryption/unlock.rs`:
```rust
pub async fn unlock_luks(device: &str, passphrase: &str) -> Result<String> {
    // From operations/luks.rs - returns cleartext path
}
```

`encryption/lock.rs`:
```rust
pub async fn lock_luks(device_path: &str) -> Result<()> {
    // From operations/luks.rs
}
```

`encryption/passphrase.rs`:
```rust
pub async fn change_luks_passphrase(
    device: &str,
    old_passphrase: &str,
    new_passphrase: &str,
) -> Result<()> {
    // From operations/luks.rs
}
```

`encryption/list.rs`:
```rust
pub async fn list_luks_devices() -> Result<Vec<LuksInfo>> {
    // From operations/luks.rs
}
```

`encryption/config.rs`:
```rust
// Crypttab management from volume_model/encryption.rs
pub async fn get_encryption_options(volume_path: &str) -> Result<Option<EncryptionOptionsSettings>> {
    // From volume_model/encryption.rs
}

pub async fn set_encryption_options(
    volume_path: &str,
    settings: EncryptionOptionsSettings,
    passphrase: Option<String>,
) -> Result<()> {
    // From volume_model/encryption.rs
}

pub async fn reset_encryption_options(volume_path: &str) -> Result<()> {
    // From volume_model/encryption.rs (was default_encryption_options)
}
```

**Delete after merge:**
- `operations/luks.rs` (logic moved to encryption/)
- `disks/volume_model/encryption.rs` (logic moved to encryption/)

---

### Phase 5: Flatten Drive Operations (Day 3 morning - 3-4 hours)

**Goal:** Create complete `disk/` module (no duplicates here, just flattening)

**Files to flatten:**

`disk/discovery.rs`:
```rust
// From disks/drive/discovery.rs - mostly keep as-is, just move
pub async fn get_drives() -> Result<Vec<DriveModel>> { ... }
pub async fn get_disks() -> Result<Vec<DiskInfo>> { ... }
pub async fn get_disks_with_volumes() -> Result<Vec<(DiskInfo, Vec<VolumeInfo>)>> { ... }
pub async fn get_disks_with_partitions() -> Result<Vec<(DiskInfo, Vec<PartitionInfo>)>> { ... }
```

`disk/format.rs`:
```rust
// From disks/drive/actions.rs
pub async fn format_disk(drive_path: OwnedObjectPath, format_type: &str, erase: bool) -> Result<()> {
    // Flatten from DriveModel::format_disk method
}
```

`disk/power.rs`:
```rust
// From disks/drive/actions.rs
pub async fn eject_drive(drive_path: OwnedObjectPath) -> Result<()> { ... }
pub async fn power_off_drive(drive_path: OwnedObjectPath) -> Result<()> { ... }
pub async fn standby_drive(drive_path: OwnedObjectPath) -> Result<()> { ... }
pub async fn wakeup_drive(drive_path: OwnedObjectPath) -> Result<()> { ... }
pub async fn remove_drive(drive_path: OwnedObjectPath) -> Result<()> { ... }
```

`disk/model.rs`:
```rust
// From disks/drive/model.rs - STRIP ALL METHODS
pub struct DriveModel {
    pub path: OwnedObjectPath,
    pub block_path: String,
    pub device: String,
    // ... all public fields
    // NO METHODS - methods become functions in disk/
}

impl DriveModel {
    // Only constructors/conversions allowed
    pub async fn from_proxy(...) -> Result<Self> { ... }
    pub async fn from_block_only(...) -> Result<Self> { ... }
}
```

`disk/volume_tree.rs`:
```rust
// From disks/drive/volume_tree.rs - internal helper, keep as-is
```

**No duplicates** - drive operations are unique

**Delete after merge:**
- `disks/drive/actions.rs` (logic moved to disk/power.rs and disk/format.rs)
- `disks/drive/model.rs` (moved to disk/model.rs)
- `disks/drive/discovery.rs` (moved to disk/discovery.rs)

---

### Phase 6: Flatten SMART Operations (Day 3 afternoon - 1-2 hours)

**Goal:** Create unified `smart/` module

`smart/info.rs`:
```rust
// From disks/drive/smart.rs
pub async fn get_drive_smart_info(drive_path: OwnedObjectPath) -> Result<SmartInfo> {
    // Flatten from DriveModel::smart_info method
}
```

`smart/test.rs`:
```rust
// From disks/drive/smart.rs
pub async fn start_drive_smart_selftest(drive_path: OwnedObjectPath, kind: SmartSelfTestKind) -> Result<()> {
    // Flatten from DriveModel::smart_selftest_start
}

pub async fn abort_drive_smart_selftest(drive_path: OwnedObjectPath) -> Result<()> {
    // Flatten from DriveModel::smart_selftest_abort
}
```

`smart/types.rs`:
```rust
// From disks/smart.rs - move type definitions
pub struct SmartInfo { ... }
pub enum SmartSelfTestKind { ... }
```

**Delete after merge:**
- `disks/drive/smart.rs` (logic moved to smart/)
- `disks/smart.rs` (types moved to smart/types.rs)

---

### Phase 7: Organize Remaining Modules (Day 4 morning - 3-4 hours)

**Goal:** Move all remaining modules into new structure

**No duplicates in these modules - just reorganize:**

`image/loop.rs`:
```rust
// From disks/image.rs
pub async fn loop_setup(image_path: &str) -> Result<OwnedObjectPath> { ... }
```

`image/mount.rs`:
```rust
// From disks/image.rs
pub async fn mount_filesystem(image_path: &str) -> Result<String> { ... }
```

`image/backup.rs`:
```rust
// From disks/image.rs and disks/volume_model/backup.rs
pub async fn open_for_backup(block_path: OwnedObjectPath) -> Result<OwnedFd> { ... }
pub async fn open_for_restore(block_path: OwnedObjectPath) -> Result<OwnedFd> { ... }
```

`lvm/list.rs`:
```rust
// From disks/lvm.rs
pub async fn list_lvs_for_pv(pv_path: &str) -> Result<Vec<String>> { ... }
```

`gpt/probe.rs`:
```rust
// From disks/gpt.rs
pub async fn probe_gpt_usable_range_bytes(device_path: &str) -> Result<(u64, u64)> { ... }
pub fn fallback_gpt_usable_range_bytes(total_bytes: u64) -> (u64, u64) { ... }
```

`manager/disk_manager.rs`:
```rust
// From disks/manager.rs
pub struct DiskManager { ... }
```

`manager/events.rs`:
```rust
// From disks/manager.rs
pub enum DeviceEvent { ... }
pub type DeviceEventStream = ...; 
```

`volume/model.rs`:
```rust
// From disks/volume_model/mod.rs - STRIP ALL METHODS
pub struct VolumeModel {
    pub volume_type: VolumeType,
    // ... all public fields
    // NO METHODS - methods already moved to partition/, filesystem/, encryption/
}

impl VolumeModel {
    // Only constructors/conversions
    pub async fn from_proxy(...) -> Result<Self> { ... }
}
```

`util/process.rs`:
```rust
// From disks/process_finder.rs
pub fn find_processes_using_mount(mount_point: &str) -> Result<Vec<ProcessInfo>> { ... }
pub fn kill_processes(pids: &[u32]) -> Result<()> { ... }
```

`util/bytestring.rs`:
```rust
// From disks/dbus/ module
// Bytestring conversion helpers
```

**Delete after merge:**
- `disks/image.rs` (moved to image/)
- `disks/lvm.rs` (moved to lvm/)
- `disks/gpt.rs` (moved to gpt/)
- `disks/manager.rs` (moved to manager/)
- `disks/volume_model/mod.rs` (moved to volume/model.rs)
- `disks/volume_model/backup.rs` (moved to image/backup.rs)
- `disks/process_finder.rs` (moved to util/process.rs)
- `disks/volume.rs` (moved to volume/node.rs)

**DO NOT MOVE** (will be deleted in Phase 9):
- `disks/ops.rs` - Backend trait abstraction (obsolete with new flat functions)

---

### Phase 8: Update Exports and Imports (Day 4 afternoon - 2-3 hours)

**Goal:** Update lib.rs and all callers

`storage-dbus/src/lib.rs`:
```rust
// Error types
pub mod error;
pub use error::DiskError;

// Shared types
pub mod types;
pub use types::*;

// Domain modules
pub mod disk;
pub mod partition;
pub mod filesystem;
pub mod encryption;
pub mod image;
pub mod smart;
pub mod lvm;
pub mod btrfs;
pub mod gpt;
pub mod manager;
pub mod volume;
pub mod util;

// Re-export commonly used items at top level
pub use disk::{DriveModel, get_drives, get_disks};
pub use volume::VolumeModel;
pub use manager::{DiskManager, DeviceEvent, DeviceEventStream};

// Re-export all operations for convenience
pub use partition::*;
pub use filesystem::*;
pub use encryption::*;
pub use image::*;
pub use smart::*;
pub use lvm::*;
pub use gpt::*;
```

**Update callers:**

1. **storage-service:** Should require minimal changes (already uses operations module)
   - Update imports: `use disks_dbus::operations::*` ‚Üí `use disks_dbus::*`
   - Already using flat function API

2. **storage-ui:** May need updates if it uses DriveModel/VolumeModel methods
   - Search and replace method calls with function calls
   - `drive.eject()` ‚Üí `disk::eject_drive(drive.path)`
   - `volume.mount()` ‚Üí `filesystem::mount_filesystem(&volume.device_path)`

---

### Phase 9: Cleanup and Final Verification (Day 5 - 4-6 hours)

**Goal:** Remove old code, eliminate backend abstraction, verify everything works

**Cleanup tasks:**

1. **Remove Backend Trait Abstraction** (2-3 hours)
   
   The `DiskBackend` trait and its implementations (`RealDiskBackend`, `FakeBackend`) were needed when operations were scattered. Now that all operations are flat functions, we can call them directly.

   **Files to delete entirely:**
   ```bash
   rm storage-dbus/src/disks/ops.rs        # Contains DiskBackend trait, RealDiskBackend, FakeBackend, + 300 lines of tests
   ```

   **Code changes - remove backend usage:**
   
   Before (with backend):
   ```rust
   // disks/drive/actions.rs
   use crate::disks::ops::{RealDiskBackend, drive_create_partition};
   
   impl DriveModel {
       pub async fn create_partition(&self, ...) -> Result<()> {
           let backend = RealDiskBackend::new(self.connection.clone());
           drive_create_partition(&backend, ...).await
       }
   }
   ```
   
   After (direct calls):
   ```rust
   // disk/format.rs
   use crate::partition;
   
   pub async fn create_partition(disk_path: &str, ...) -> Result<()> {
       // Direct call to domain function
       partition::create_partition(disk_path, ...).await
   }
   ```

   **Affected files to update** (remove RealDiskBackend usage):
   - `disks/drive/actions.rs` - 3 uses of RealDiskBackend
   - `disks/volume_model/filesystem.rs` - 1 use
   - `disks/volume_model/mount.rs` - 2 uses
   
   These files will be deleted/moved in earlier phases, so backend removal happens **after** Phase 7 completes.

   **Tests to remove:**
   - `ops.rs` contains ~340 lines of backend trait tests:
     - `FakeBackend` implementation (~140 lines)
     - Unit tests for argument building (~100 lines) 
     - Integration tests with fake backend (~100 lines)
   - These tests will be replaced by integration tests (outside scope of GAP-001.b)

2. **Delete old directories:**
```bash
rm -rf storage-dbus/src/operations/     # Merged into domain modules
rm -rf storage-dbus/src/disks/drive/    # Merged into disk/
rm -rf storage-dbus/src/disks/volume_model/  # Merged into volume/, partition/, filesystem/, encryption/
rm -rf storage-dbus/src/disks/          # Everything moved out
```

3. **Delete old files:**
```bash
rm storage-dbus/src/disks/image.rs      # ‚Üí image/
rm storage-dbus/src/disks/lvm.rs        # ‚Üí lvm/
rm storage-dbus/src/disks/gpt.rs        # ‚Üí gpt/
rm storage-dbus/src/disks/smart.rs      # ‚Üí smart/types.rs
rm storage-dbus/src/disks/process_finder.rs  # ‚Üí util/process.rs
rm storage-dbus/src/disks/volume.rs     # ‚Üí volume/node.rs
rm storage-dbus/src/disks/mod.rs        # No longer needed
# ops.rs already deleted in step 1
```

4. **Verify builds:**
```bash
cargo clean
cargo build --workspace
cargo test --workspace   # All backend unit tests removed; remaining tests should pass
```

5. **Run smoke tests:**
   - List disks: `cargo run --bin test-list-disks`
   - Create partition (on test disk)
   - Format filesystem
   - Mount/unmount
   - LUKS operations (on test device)
   
   Note: Comprehensive testing will be done via integration tests (outside GAP-001.b scope).

6. **Documentation:**
   - Update storage-dbus README with new structure
   - Add migration guide for callers
   - Document each module's purpose
   - Note: Backend trait removed - all operations are now direct flat functions

---

## Implementation Strategy

### Day-by-Day Breakdown

**Day 1: Foundation + Partitions + Filesystems**
- Morning: Phase 1 (structure setup)
- Afternoon: Phase 2 (partition operations)
- Evening: Phase 3 (filesystem operations)

**Day 2: Encryption + Drive**
- Morning: Phase 4 (encryption operations)
- Afternoon: Phase 5 (drive operations)

**Day 3: SMART + Remaining**
- Morning: Phase 6 (SMART operations)
- Afternoon: Phase 7 (remaining modules)

**Day 4: Integration + Exports**
- Morning: Phase 7 continued
- Afternoon: Phase 8 (exports and imports)

**Day 5: Cleanup + Testing**
- Morning: Phase 9 - Backend trait removal (2-3h)
- Afternoon: Phase 9 - Final cleanup, verification, documentation (2-3h)

**Total: 5 days** (23-33 hours estimated, includes testing, documentation, and buffer time)

---

## Duplicate Resolution Matrix

Complete list of all duplicates found and resolution decisions:

| Operation | operations/ | volume_model/ | drive/ | Resolution |
|-----------|------------|---------------|--------|------------|
| **Partitions** | | | | |
| create_table | ‚úÖ partitions.rs | | ‚úÖ format_disk | **Keep operations** - direct |
| create | ‚úÖ partitions.rs | | ‚úÖ actions.rs | **Keep operations** |
| delete | ‚úÖ partitions.rs | ‚úÖ partition.rs | | **Merge** - add unmount logic |
| resize | ‚úÖ partitions.rs | ‚úÖ partition.rs | | **Keep operations** |
| set_type | ‚úÖ partitions.rs | ‚úÖ partition.rs | | **Keep operations** |
| set_name | ‚úÖ partitions.rs | ‚úÖ partition.rs | | **Keep operations** |
| set_flags | ‚úÖ partitions.rs | ‚úÖ partition.rs | | **Keep operations** |
| edit (all-in-one) | | ‚úÖ partition.rs | | **Keep volume_model** |
| **Filesystems** | | | | |
| format | ‚úÖ filesystems.rs | ‚úÖ filesystem.rs | | **Keep operations** |
| mount | ‚úÖ filesystems.rs | ‚úÖ mount.rs | | **Keep operations** |
| unmount | ‚úÖ filesystems.rs | ‚úÖ mount.rs | | **Keep operations** |
| check | ‚úÖ filesystems.rs | ‚úÖ filesystem.rs | | **Keep operations** |
| repair | | ‚úÖ filesystem.rs | | **Keep volume_model** (wrapper) |
| get_label | ‚úÖ filesystems.rs | | | **Keep operations** |
| set_label | ‚úÖ filesystems.rs | ‚úÖ filesystem.rs | | **Keep operations** |
| take_ownership | ‚úÖ filesystems.rs | ‚úÖ filesystem.rs | | **Keep operations** |
| get_mount_point | ‚úÖ filesystems.rs | | | **Keep operations** |
| mount_options | | ‚úÖ mount.rs + config.rs | | **Keep volume_model** |
| **Encryption** | | | | |
| format_luks | ‚úÖ luks.rs | | | **Keep operations** |
| unlock | ‚úÖ luks.rs | ‚úÖ encryption.rs | | **Keep operations** |
| lock | ‚úÖ luks.rs | ‚úÖ encryption.rs | | **Keep operations** |
| change_passphrase | ‚úÖ luks.rs | ‚úÖ encryption.rs | | **Keep operations** |
| list_devices | ‚úÖ luks.rs | | | **Keep operations** |
| encryption_options | | ‚úÖ encryption.rs | | **Keep volume_model** |
| **Image/Backup** | | | | |
| open_for_backup | | ‚úÖ backup.rs | ‚úÖ actions.rs | **Merge** - both needed |
| open_for_restore | | ‚úÖ backup.rs | ‚úÖ actions.rs | **Merge** - both needed |

**Decision Criteria:**
1. **Completeness**: More parameters, better error handling
2. **Quality**: Cleaner code, fewer dependencies
3. **Correctness**: Proper D-Bus usage, edge cases handled
4. **Recency**: operations/ module is newer (GAP-001), often better

---

## Benefits

**1. Architectural Consistency**
- Single pattern throughout entire codebase
- Easy to understand: "Want X operation? Check X module"
- No confusion about OOP vs functional styles

**2. Eliminated Duplication**
- ~20 duplicate operations merged into single implementations
- Single source of truth for each operation
- Reduced maintenance burden (no syncing needed)

**3. Better Organization**
- Domain-based structure is intuitive
- Related operations grouped together
- Clear module boundaries

**4. Improved Discoverability**
- All operations visible in lib.rs exports
- IDE autocomplete shows all available operations
- Clear naming: domain + action (e.g., `disk::eject_drive`)

**5. Easier Testing**
- Flat functions easier to test than methods
- No need to construct complex model objects
- Can mock identifiers easily

**6. Simplified API**
- Consistent function signatures across all domains
- No hidden state in method calls
- Explicit identifiers make control flow clear

**7. Future-Proof**
- Easy to add new domains (e.g., `mdraid/`, `zfs/`)
- Clear pattern for new operations
- Extensible without breaking existing code

---

## Risks and Mitigations

### Risk 1: Breaking storage-ui during transition
**Impact:** High - UI might fail to compile  
**Probability:** High - UI likely uses DriveModel/VolumeModel methods  
**Mitigation:**
- Phase imports incrementally (one domain at a time)
- Add temporary compatibility wrappers if needed
- Comprehensive search for method calls before removing
- Keep both old and new code until UI is updated

### Risk 2: Lost functionality during merge
**Impact:** High - Users can't perform operations  
**Probability:** Medium - Complex refactoring with many files  
**Mitigation:**
- Careful comparison of duplicate implementations
- Keep better version, document decision
- Test each operation after merging
- Incremental commits (one domain at a time)

### Risk 3: Regression in edge case handling
**Impact:** Medium - Some operations might fail in specific scenarios  
**Probability:** Medium - Subtle logic in method implementations  
**Mitigation:**
- Read all method implementations carefully
- Preserve all error handling logic
- Preserve all D-Bus option settings
- Manual testing of edge cases (busy devices, missing mounts, etc.)

### Risk 4: Performance degradation
**Impact:** Low - Operations might be slower  
**Probability:** Low - Connection caching is minimal concern  
**Mitigation:**
- zbus caches connections internally (minimal overhead)
- Measure operation times before/after
- Can add connection pooling if needed

### Risk 5: Incomplete migration (stuck halfway)
**Impact:** High - Codebase in inconsistent state  
**Probability:** Medium - Large refactoring might stall  
**Mitigation:**
- Clear phase boundaries (each day produces working code)
- Each phase is independently testable
- Can stop after any phase with partial benefits
- Document current state clearly if paused

---

## Success Criteria

### Phase Completion Criteria

Each phase must meet these before moving to next:

1. **Code compiles** - `cargo build --workspace` succeeds
2. **Tests pass** - `cargo test --workspace` passes
3. **Phase goal met** - All operations for that domain migrated
4. **Old code removed** - Duplicate code deleted (if applicable)
5. **Exports updated** - New module exported in lib.rs

### Final Acceptance Criteria

1. ‚úÖ All operations moved to domain modules (disk/, partition/, filesystem/, encryption/, image/, smart/, lvm/, etc.)
2. ‚úÖ All duplicates resolved - single implementation per operation
3. ‚úÖ DriveModel and VolumeModel are data-only (no methods except constructors)
4. ‚úÖ `/operations/` directory deleted (merged into domain modules)
5. ‚úÖ `/disks/drive/` directory deleted (merged into disk/)
6. ‚úÖ `/disks/volume_model/` directory deleted (merged into domain modules)
7. ‚úÖ All old standalone modules moved (image, lvm, gpt, smart, etc.)
8. ‚úÖ All operations exported at top level in lib.rs
9. ‚úÖ storage-service builds and runs (minimal/no changes expected)
10. ‚úÖ storage-ui builds and runs (method calls converted to functions)
11. ‚úÖ Full workspace compiles: `cargo build --workspace`
12. ‚úÖ All tests pass: `cargo test --workspace`
13. ‚úÖ Smoke tests pass (manual testing of key operations)
14. ‚úÖ Documentation updated (README, migration guide)

---

## Estimated Timeline

**Conservative estimate:** 5-7 days  
**Optimistic estimate:** 4-5 days  
**With contingency:** 7 days

### Detailed Breakdown

| Phase | Task | Time | Dependencies |
|-------|------|------|--------------|
| 1 | Structure setup | 2-3h | None |
| 2 | Partition operations | 3-4h | Phase 1 |
| 3 | Filesystem operations | 3-4h | Phase 1 |
| 4 | Encryption operations | 2-3h | Phase 1 |
| 5 | Drive operations | 3-4h | Phase 1 |
| 6 | SMART operations | 1-2h | Phase 1 |
| 7 | Remaining modules | 3-4h | Phase 1 |
| 8 | Exports and imports | 2-3h | Phases 2-7 |
| 9 | Cleanup and testing | 4-6h | Phase 8 |
| **Total** | **23-33 hours** | **~5 days** | |

### By Day

- **Day 1**: Phases 1-3 (foundation, partitions, filesystems)
- **Day 2**: Phases 4-5 (encryption, drive)
- **Day 3**: Phases 6-7 (SMART, remaining)
- **Day 4**: Phase 8 (integration)
- **Day 5**: Phase 9 (cleanup, testing, documentation)

**Buffer time**: Built into estimates (conservative hours)
